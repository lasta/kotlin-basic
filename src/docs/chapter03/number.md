# 数
多くのプログラミング言語では、数を整数と実数の2種類に分けて考えます。
これは、コンピュータは整数を扱うのが得意であることに対し、小数を扱うには一工夫が必要となるためです。

## 整数

| 型名      | ビット数 | 最小値                                       | 最大値                                          |
|-----------|----------|----------------------------------------------|-------------------------------------------------|
| Byte      | 8        | -128                                         | 127                                             |
| Short     | 16       | -32768                                       | 32767                                           |
| **Int**   | 32       | -2,147,483,648<br />($$2^{-31}$$)            | 2,147,483,647<br />($$2^{31} - 1$$)             |
| Long      | 64       | -9,223,372,036,854,775,808<br />($$2^{63}$$) | 9,223,372,036,854,775,807<br />($$2^{63} - 1$$) |

主に使用される整数型は Int 型です。
整数リテラル (プログラム上に直接書かれた整数; `42` など) は基本的には Int 型として扱われますが、よしなに判断してくれる場合があります。

```kotlin
// すべて OK. 変数は指定した型になる.
val byte: Byte = 42
val short: Short = 42
val int: Int = 42
val long: Long = 42

// 型推論により, 変数 num は Int 型
val num = 42
```

整数リテラルを明示的に Long 型として扱いたい場合は、整数の末尾に `L` をつけます。

```kotlin
// 明示的に指定しているため、 Long 型以外として扱うことができない
val byte: Byte = 42L // NG
val short: Short = 42L // NG
val int: Int = 42L // NG
val long: Long = 42L // OK

// 型推論により, 変数 num は Long 型
val num = 42L
```

明示的に Byte 型、 Short 型として扱う記法はありません。

{% hint style="tip" %}
なぜ Int 型を使うことが多いのか

1ビットごとにデータを読み込むと効率が悪いため、ある程度まとめてデータを読み書きします。
1ワード (= 4バイト = 32ビット) ごとに読み込むことが多いため、  Byte 型および Short 型を使っても Int 型と効率が変わらない場合が多いです。

Int 型では扱い切れないほど大きい整数を扱う場合は Long 型、そうではない場合は Int 型を使うことを推奨します。
{% endhint %}

{% hint style="tip" %}
符号なし整数型

0と正の整数のみを扱える型です。
Kotlin 1.3 からから符号なし整数型が導入されました。ただし、まだ試験的導入 (Experimental) の段階です。
Kotlin 1.4 から正式に導入される予定とされています。
詳しくは [こちらを参照](https://kotlinlang.org/docs/reference/basic-types.html#experimental-status-of-unsigned-integers) してください。

| 型名   | ビット数 | 最小値 | 最大値                     |
|--------|----------|--------|----------------------------|
| UByte  | 8        | 0      | 255                        |
| UShort | 16       | 0      | 65535                      |
| UInt   | 32       | 0      | 4,294,967,295              |
| ULong  | 64       | 0      | 18,446,744,073,709,551,616 |

{% endhint %}

{% hint style="tip" %}
他の整数リテラルの記法

* 16進数: 先頭に `0x` をつける
* 2進数: 先頭に `0b` をつける

```kotlin
val hex: Int = 0x0F // 10進数で 15
val binary: Int = 0b1111 // 10進数で 15
```

8進数の記法はありません。
{% endhint %}

{% hint style="tip" %}
桁の区切り文字 `_`

数値リテラルの可読性を高めるために、区切り文字として `_` を使うことができます。

```kotlin
val oneMillion = 1_000_000 // 1000000 と同じ
val creditCardNumber = 1234_5678_9012_3456L // 1234567890123456 と同じ
val hexBytes = 0xFF_EC_DE_5E // 0xFFECDE5E (4293713502) と同じ
```
{% endhint %}

## 浮動小数点数

| 型名       | ビット数 | 最小値                              | 最大値                                                          |
|------------|----------|-------------------------------------|-----------------------------------------------------------------|
| Float      | 32       | 1.4E-45 ($$1.4 \times 10^{-45}$$)   | 3.4028235E38 ($$3.4028235 \times 10^{38}$$)                     |
| **Double** | 64       | 4.9E-324 ($$4.9 \times 10^{-324}$$) | 1.7976931348623157E308 ($$1.7976931348623157 \times 10^{308}$$) |

主に使用される浮動小数点数型は Double 型です。
整数リテラルと異なり、浮動小数点数リテラルは Double としてしか扱われません。
Float 型として扱うためには、末尾に `f` または `F` をつけます。

```kotlin
val double: Double = 12.3 // OK
val ngFloat: Float = 12.3 // NG
val okFloat: Float = 12.3f // OK

// 型推論により, 変数 d は Double 型
val d = 12.3

// 型推論により, 変数 f は Float 型
val f = 12.3f
```

{% hint style="tip" %}
他の浮動小数点数リテラルの記法

「仮数」 + 「e」 または 「E」 + 「整数」 で浮動小数点表記ができます。

```kotlin
val a: Double = 1.23e8 // 1.23 * 10^3 = 1230.0
val b: Double = 4.56e-2 // 4.56 * 10^(-2) = 0.0456
```
{% endhint %}

{% hint style="tip" %}
なぜ Double 型を使うことが多いのか

整数型と違い、浮動小数点数型の場合は数の大きさだけではなく、精度 (有効桁数) にも注意する必要があります。
たとえば、 1.0f (Float 型の 1.0) より大きい最小の数は 1.0000001f です。
一方で Double 型の場合は 1.000000000000001 になります。

求められる精度が低くてもよく、かつ大量のデータを扱う場合のみ Float 型を、そうではない場合は Double 型を使うことを推奨します。
{% endhint %}

## 数値型同士の型変換
Int 型の変数 `a` があるとします。
変数 `a` を Double 型の変数 `b` に代入しようとすると、失敗します。

```kotlin
val a: Int = 42
val b: Double = a // 型エラー
```

このような場合には、 **型変換** が必要になります。

{% hint style="info" %}
型変換 (type conversion)

ある型を別の型に変換すること  
型キャスト (type cast) とも呼ばれる
{% endhint %}

Kotlin では、数値型から別の各数値型への変換を行うことができます。

例えば Int 型から Double 型への変換をする場合は、 `.toDouble()` を末尾につけます。
(`.toDouble()` の正体は Chapter 5 関数 で明かします)

```kotlin
val a: Int = 42
val b: Double = a.toDouble() // OK
```

逆に、浮動小数点数を整数型に変換するとどうなるでしょうか。

```kotlin
val c: Double = 12.3
val d: Int = c.toInt() // 12
```

整数型 Int では小数を扱うことができないため、小数点以下の値は切り捨てられます。
このように、型変換を行うと情報が欠落する場合があることに注意しましょう。

{% hint style="tip" %}
明示的な型変換 と 暗黙的な型変換

* 明示的な型変換
    * 変換先の型を指定した型変換
* 暗黙的な型変換
    * 明示的に指定せずに変換先の型の判断をコンパイラに任せた型変換

Kotlin には暗黙的な型変換はありません。
{% endhint %}
