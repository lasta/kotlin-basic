# 数の演算
四則演算を始め、様々な演算を行うことができます。

## 四則演算
<!-- 加減乗除余のはなし -->
数値型同士は四則演算を行う事ができます。

```kotlin
1 + 1 // kotlin.Int = 2
2.3 - 4.5 // kotlin.Double = -2.2
2 * 3 // kotlin.Int = 6
9 / 3 // kotlin.Int = 3
9 % 2 // kotlin.Int = 1
```

| 演算子名                  | 記法            |
|---------------------------|-----------------|
| 加算演算子 (足し算)       | `a + b`         |
| 減算演算子 (引き算)       | `a - b`         |
| 乗算演算子 (掛け算)       | `a * b`         |
| 除算演算子 (割り算)       | `a / b`         |
| 剰余演算子 (割り算の余り) | `a % b`         |

異なる数値型 (`Int` 型と `Double` 型など) 同士で演算した場合、より表現力の大きい型に変換されます。
例えば、 `Int` 型と `Double` 型で演算した場合、結果は `Double` 型になります。
ただし、 `Short` 型や `Byte` 型での演算の結果は `Int` 型になります。

```kotlin
1 + 2.0 // kotlin.Double = 3.0
2 + 3L // kotlin.Long = 5
4.0f + 5.0 // kotlin.Double = 9.0
4.0f + 5 // kotlin.Float = 9.0
4.toShort() + 5.toByte() // kotlin.Int = 9
```

### 整数同士の除算
同じ数値型同士で演算した場合、結果も同じ数値型になります。
つまり、 `Int` 型同士で除算を行った場合の結果も `Int` 型になります。
演算の結果小数部が発生した場合は、切り捨てられます。

```kotlin
1 / 3 // kotlin.Int = 0
```

### 浮動小数点数演算の誤差
コンピュータの内部では、2進数でデータを扱います。
数値型も例外ではなく、例えば10進数の整数 `42` はコンピュータ内部では2進数の整数 `101010` として扱います。

加えて、浮動小数点数型 (`Float` 型と `Double` 型) は扱える精度に限界があります。
例えば、 `Double` 型で10進数 `1.0000000000000001` を扱うことはできないため、
扱える範囲で最も近い値 `1.0` に変換します。この値を近似値と呼びます。
このような扱える精度の限界を超えた場合に発生する誤差を丸め誤差と呼びます。

この2つの事実を組み合わせると、一見簡単な計算でも丸め誤差が発生します。

```kotlin
1.0 - 0.7 // kotlin.Double = 0.30000000000000004
```

{% hint style="tip" %}
なぜ `1.0 - 0.7 = 0.30000000000000004` なのか

Kotlin では浮動小数点数の表現方式として [IEEE 754](https://ja.wikipedia.org/wiki/IEEE_754) と呼ばれる標準規格を用います。
`Double` 型は倍精度浮動小数点数で表現されます。

* 10進数表記 `1.0`
    * 2進数
        * 倍精度 IEEE754 内部表現 `0b0011111111110000000000000000000000000000000000000000000000000000`
        * 小数表現 `1.0`
* 10進数表記 `0.7`
    * 2進数
        * 倍精度 IEEE754 内部表現 `0b0011111111100110011001100110011001100110011001100110011001100110`
        * 小数表現`0.101100110011...`
    
`0.7` を IEEE754 に従い2進数へ変換すると、循環小数になります。 (`0b0.101100110011...`)
有限小数と循環小数 (無限小数) を引き算すると結果は無限小数になります。
その結果、 `1.0 - 0.7 = 0.30000000000000004` になります。
{% endhint %}


{% hint style="tip" %}
インクリメント演算子とデクリメント演算子

Java 等の言語と同様に、 Kotlin もインクリメント演算子 (`++`) とデクリメント演算子 (`--`) があります。
インクリメント演算子は変数の値に +1 、デクリメント演算子は変数の値に `-1` した値を **代入** します。

代入、すなわち値の更新があるため、変数は `val` ではなく `var` で宣言する必要があります。

前置記法 (`++a`) と後置記法 (`a++`) の2種類があり、前置記法の場合は変数の値に `1` を足した後に変数の値の呼び出しを、
後置記法の場合は変数の値を読んだ後に `1` を足します。

```kotlin
var a = 0
println(a++) // 0
println(a) // 1

a = 0
println(++a) // 1
println(a) // 1
```

インクリメント演算子およびデクリメント演算子の主な用途は、繰り返し処理の際のカウンタです。

```java
// Java
public class Main {
    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            System.out.print("%d, ", i); // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 
        }
    }
}
```

詳しくは [9 章「コレクション」](../chpater09/chapter09.md) の「繰り返し処理」にて解説しますが、 Kotlin にはこのような for 文はありません。
似たようなことを行いたい場合、下記のように記述します。

```kotlin
// インクリメント演算子 `++` は出現しない
repeat(10) { print("$it, ") } // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 
``` 

加えて、 Kotlin では可能な限り変数の値は変化しない (イミュータブル) ようにすることを好みます。

以上から、インクリメント演算子およびデクリメント演算子はあまり用いられません。
{% endhint %}

{% hint style="tip" %}
累算代入演算子 (Augmented assignments)

Java 等の言語と同様に、 Kotlin にも累算代入演算子があります。

| 演算子名       | 記法     | 等価な記法  |
|----------------|----------|-------------|
| 累算加算演算子 | `a += b` | `a = a + b` |
| 累算減算演算子 | `a -= b` | `a = a - b` |
| 累算乗算演算子 | `a *= b` | `a = a * b` |
| 累算除算演算子 | `a /= b` | `a = a / b` |
| 累算剰余演算子 | `a %= b` | `a = a % b` |

等価な記法から分かる通り、インクリメント演算子と同様に累算演算子も値の再代入があるため、変数は `var` で宣言する必要があります。
{% endhint %}
